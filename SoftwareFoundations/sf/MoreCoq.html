<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>MoreCoq: More About Coq</title>
<script type="text/javascript" src="jquery-1.8.3.js"></script>
<script type="text/javascript" src="main.js"></script>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">MoreCoq<span class="subtitle">More About Coq</span></h1>

<div class="code code-tight">
</div>

<div class="doc">

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <span class="id" type="var">Poly</span>.<br/>

<br/>
</div>

<div class="doc">
This chapter introduces several more Coq tactics that,
    together, allow us to prove many more theorems about the
    functional programs we are writing. 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab156"></a><h1 class="section">The <span class="inlinecode"><span class="id" type="tactic">apply</span></span> Tactic</h1>

<div class="paragraph"> </div>

 We often encounter situations where the goal to be proved is
    exactly the same as some hypothesis in the context or some
    previously proved lemma. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">silly1</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span> <span class="id" type="var">p</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">n</span> = <span class="id" type="var">m</span>  <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">n</span>;<span class="id" type="var">o</span>] = [<span class="id" type="var">n</span>;<span class="id" type="var">p</span>] <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">n</span>;<span class="id" type="var">o</span>] = [<span class="id" type="var">m</span>;<span class="id" type="var">p</span>].<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span> <span class="id" type="var">p</span> <span class="id" type="var">eq1</span> <span class="id" type="var">eq2</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&larr;</span> <span class="id" type="var">eq1</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;At&nbsp;this&nbsp;point,&nbsp;we&nbsp;could&nbsp;finish&nbsp;with&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"<span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">eq2</span>.</span> <span class="inlinecode"><span class="id" type="tactic">reflexivity</span>.</span>"&nbsp;as&nbsp;we&nbsp;have&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;done&nbsp;several&nbsp;times&nbsp;above.&nbsp;But&nbsp;we&nbsp;can&nbsp;achieve&nbsp;the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;same&nbsp;effect&nbsp;in&nbsp;a&nbsp;single&nbsp;step&nbsp;by&nbsp;using&nbsp;the&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="inlinecode"><span class="id" type="tactic">apply</span></span>&nbsp;tactic&nbsp;instead:&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">eq2</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" type="tactic">apply</span></span> tactic also works with <i>conditional</i> hypotheses
    and lemmas: if the statement being applied is an implication, then
    the premises of this implication will be added to the list of
    subgoals needing to be proved. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">silly2</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span> <span class="id" type="var">p</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">n</span> = <span class="id" type="var">m</span>  <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span>(<span class="id" type="var">q</span> <span class="id" type="var">r</span> : <span class="id" type="var">nat</span>), <span class="id" type="var">q</span> = <span class="id" type="var">r</span> <span style="font-family: arial;">&rarr;</span> [<span class="id" type="var">q</span>;<span class="id" type="var">o</span>] = [<span class="id" type="var">r</span>;<span class="id" type="var">p</span>]) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">n</span>;<span class="id" type="var">o</span>] = [<span class="id" type="var">m</span>;<span class="id" type="var">p</span>].<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span> <span class="id" type="var">p</span> <span class="id" type="var">eq1</span> <span class="id" type="var">eq2</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">eq2</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">eq1</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
You may find it instructive to experiment with this proof
    and see if there is a way to complete it using just <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span>
    instead of <span class="inlinecode"><span class="id" type="tactic">apply</span></span>. 
<div class="paragraph"> </div>

 Typically, when we use <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span>, the statement <span class="inlinecode"><span class="id" type="var">H</span></span> will
    begin with a <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> binding some <i>universal variables</i>.  When
    Coq matches the current goal against the conclusion of <span class="inlinecode"><span class="id" type="var">H</span></span>, it
    will try to find appropriate values for these variables.  For
    example, when we do <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">eq2</span></span> in the following proof, the
    universal variable <span class="inlinecode"><span class="id" type="var">q</span></span> in <span class="inlinecode"><span class="id" type="var">eq2</span></span> gets instantiated with <span class="inlinecode"><span class="id" type="var">n</span></span> and <span class="inlinecode"><span class="id" type="var">r</span></span>
    gets instantiated with <span class="inlinecode"><span class="id" type="var">m</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">silly2a</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">n</span>,<span class="id" type="var">n</span>) = (<span class="id" type="var">m</span>,<span class="id" type="var">m</span>)  <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span>(<span class="id" type="var">q</span> <span class="id" type="var">r</span> : <span class="id" type="var">nat</span>), (<span class="id" type="var">q</span>,<span class="id" type="var">q</span>) = (<span class="id" type="var">r</span>,<span class="id" type="var">r</span>) <span style="font-family: arial;">&rarr;</span> [<span class="id" type="var">q</span>] = [<span class="id" type="var">r</span>]) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">n</span>] = [<span class="id" type="var">m</span>].<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">eq1</span> <span class="id" type="var">eq2</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">eq2</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">eq1</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab157"></a><h4 class="section">Exercise: 2 stars, optional (silly_ex)</h4>
 Complete the following proof without using <span class="inlinecode"><span class="id" type="tactic">simpl</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">silly_ex</span> : <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>, <span class="id" type="var">evenb</span> <span class="id" type="var">n</span> = <span class="id" type="var">true</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">oddb</span> (<span class="id" type="var">S</span> <span class="id" type="var">n</span>) = <span class="id" type="var">true</span>) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">evenb</span> 3 = <span class="id" type="var">true</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">oddb</span> 4 = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 To use the <span class="inlinecode"><span class="id" type="tactic">apply</span></span> tactic, the (conclusion of the) fact
    being applied must match the goal <i>exactly</i> &mdash; for example, <span class="inlinecode"><span class="id" type="tactic">apply</span></span>
    will not work if the left and right sides of the equality are
    swapped. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">silly3_firsttry</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">true</span> = <span class="id" type="var">beq_nat</span> <span class="id" type="var">n</span> 5  <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">beq_nat</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">n</span>)) 7 = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Here&nbsp;we&nbsp;cannot&nbsp;use&nbsp;<span class="inlinecode"><span class="id" type="tactic">apply</span></span>&nbsp;directly&nbsp;*)</span><br/>
<span class="id" type="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
In this case we can use the <span class="inlinecode"><span class="id" type="tactic">symmetry</span></span> tactic, which switches the
    left and right sides of an equality in the goal. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">silly3</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">true</span> = <span class="id" type="var">beq_nat</span> <span class="id" type="var">n</span> 5  <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">beq_nat</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">n</span>)) 7 = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">symmetry</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="comment">(*&nbsp;Actually,&nbsp;this&nbsp;<span class="inlinecode"><span class="id" type="tactic">simpl</span></span>&nbsp;is&nbsp;unnecessary,&nbsp;since&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="inlinecode"><span class="id" type="tactic">apply</span></span>&nbsp;will&nbsp;perform&nbsp;simplification&nbsp;first.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab158"></a><h4 class="section">Exercise: 3 stars (apply_exercise1)</h4>
 Hint: you can use <span class="inlinecode"><span class="id" type="tactic">apply</span></span> with previously defined lemmas, not
    just hypotheses in the context.  Remember that <span class="inlinecode"><span class="id" type="var">SearchAbout</span></span> is
    your friend. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">rev_exercise1</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">l</span> <span class="id" type="var">l'</span> : <span class="id" type="var">list</span> <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">l</span> = <span class="id" type="var">rev</span> <span class="id" type="var">l'</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">l'</span> = <span class="id" type="var">rev</span> <span class="id" type="var">l</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab159"></a><h4 class="section">Exercise: 1 star, optional (apply_rewrite)</h4>
 Briefly explain the difference between the tactics <span class="inlinecode"><span class="id" type="tactic">apply</span></span> and
    <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span>.  Are there situations where both can usefully be
    applied?
  <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
 <font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab160"></a><h1 class="section">The <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" type="keyword">with</span></span> <span class="inlinecode">...</span> Tactic</h1>

<div class="paragraph"> </div>

 The following silly example uses two rewrites in a row to
    get from <span class="inlinecode">[<span class="id" type="var">a</span>,<span class="id" type="var">b</span>]</span> to <span class="inlinecode">[<span class="id" type="var">e</span>,<span class="id" type="var">f</span>]</span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">trans_eq_example</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">a</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> <span class="id" type="var">d</span> <span class="id" type="var">e</span> <span class="id" type="var">f</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">a</span>;<span class="id" type="var">b</span>] = [<span class="id" type="var">c</span>;<span class="id" type="var">d</span>] <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">c</span>;<span class="id" type="var">d</span>] = [<span class="id" type="var">e</span>;<span class="id" type="var">f</span>] <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">a</span>;<span class="id" type="var">b</span>] = [<span class="id" type="var">e</span>;<span class="id" type="var">f</span>].<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">a</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> <span class="id" type="var">d</span> <span class="id" type="var">e</span> <span class="id" type="var">f</span> <span class="id" type="var">eq1</span> <span class="id" type="var">eq2</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">eq1</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">eq2</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Since this is a common pattern, we might
    abstract it out as a lemma recording once and for all
    the fact that equality is transitive. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">trans_eq</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) (<span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span> : <span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;<span class="id" type="var">n</span> = <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">m</span> = <span class="id" type="var">o</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">n</span> = <span class="id" type="var">o</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">X</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span> <span class="id" type="var">eq1</span> <span class="id" type="var">eq2</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">eq1</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">eq2</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Now, we should be able to use <span class="inlinecode"><span class="id" type="var">trans_eq</span></span> to
    prove the above example.  However, to do this we need
    a slight refinement of the <span class="inlinecode"><span class="id" type="tactic">apply</span></span> tactic. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">trans_eq_example'</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">a</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> <span class="id" type="var">d</span> <span class="id" type="var">e</span> <span class="id" type="var">f</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">a</span>;<span class="id" type="var">b</span>] = [<span class="id" type="var">c</span>;<span class="id" type="var">d</span>] <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">c</span>;<span class="id" type="var">d</span>] = [<span class="id" type="var">e</span>;<span class="id" type="var">f</span>] <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">a</span>;<span class="id" type="var">b</span>] = [<span class="id" type="var">e</span>;<span class="id" type="var">f</span>].<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">a</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> <span class="id" type="var">d</span> <span class="id" type="var">e</span> <span class="id" type="var">f</span> <span class="id" type="var">eq1</span> <span class="id" type="var">eq2</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;If&nbsp;we&nbsp;simply&nbsp;tell&nbsp;Coq&nbsp;<span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">trans_eq</span></span>&nbsp;at&nbsp;this&nbsp;point,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it&nbsp;can&nbsp;tell&nbsp;(by&nbsp;matching&nbsp;the&nbsp;goal&nbsp;against&nbsp;the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;conclusion&nbsp;of&nbsp;the&nbsp;lemma)&nbsp;that&nbsp;it&nbsp;should&nbsp;instantiate&nbsp;<span class="inlinecode"><span class="id" type="var">X</span></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with&nbsp;<span class="inlinecode">[<span class="id" type="var">nat</span>]</span>,&nbsp;<span class="inlinecode"><span class="id" type="var">n</span></span>&nbsp;with&nbsp;<span class="inlinecode">[<span class="id" type="var">a</span>,<span class="id" type="var">b</span>]</span>,&nbsp;and&nbsp;<span class="inlinecode"><span class="id" type="var">o</span></span>&nbsp;with&nbsp;<span class="inlinecode">[<span class="id" type="var">e</span>,<span class="id" type="var">f</span>]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;However,&nbsp;the&nbsp;matching&nbsp;process&nbsp;doesn't&nbsp;determine&nbsp;an<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instantiation&nbsp;for&nbsp;<span class="inlinecode"><span class="id" type="var">m</span></span>:&nbsp;we&nbsp;have&nbsp;to&nbsp;supply&nbsp;one&nbsp;explicitly<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;by&nbsp;adding&nbsp;<span class="inlinecode"><span class="id" type="keyword">with</span></span> <span class="inlinecode">(<span class="id" type="var">m</span>:=[<span class="id" type="var">c</span>,<span class="id" type="var">d</span>])</span>&nbsp;to&nbsp;the&nbsp;invocation&nbsp;of<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="inlinecode"><span class="id" type="tactic">apply</span></span>.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">trans_eq</span> <span class="id" type="keyword">with</span> (<span class="id" type="var">m</span>:=[<span class="id" type="var">c</span>;<span class="id" type="var">d</span>]). <span class="id" type="tactic">apply</span> <span class="id" type="var">eq1</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">eq2</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
 Actually, we usually don't have to include the name <span class="inlinecode"><span class="id" type="var">m</span></span>
    in the <span class="inlinecode"><span class="id" type="keyword">with</span></span> clause; Coq is often smart enough to
    figure out which instantiation we're giving. We could
    instead write: <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">trans_eq</span></span> <span class="inlinecode"><span class="id" type="keyword">with</span></span> <span class="inlinecode">[<span class="id" type="var">c</span>,<span class="id" type="var">d</span>]</span>. 
<div class="paragraph"> </div>

<a name="lab161"></a><h4 class="section">Exercise: 3 stars, optional (apply_with_exercise)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Example</span> <span class="id" type="var">trans_eq_exercise</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span> <span class="id" type="var">p</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">m</span> = (<span class="id" type="var">minustwo</span> <span class="id" type="var">o</span>) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">n</span> + <span class="id" type="var">p</span>) = <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">n</span> + <span class="id" type="var">p</span>) = (<span class="id" type="var">minustwo</span> <span class="id" type="var">o</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab162"></a><h1 class="section">The <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> tactic</h1>

<div class="paragraph"> </div>

 Recall the definition of natural numbers:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Inductive</span>&nbsp;<span class="id" type="var">nat</span>&nbsp;:&nbsp;<span class="id" type="keyword">Type</span>&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">O</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">S</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">nat</span>.
<div class="paragraph"> </div>

</div>
    It is clear from this definition that every number has one of two
    forms: either it is the constructor <span class="inlinecode"><span class="id" type="var">O</span></span> or it is built by applying
    the constructor <span class="inlinecode"><span class="id" type="var">S</span></span> to another number.  But there is more here than
    meets the eye: implicit in the definition (and in our informal
    understanding of how datatype declarations work in other
    programming languages) are two other facts:

<div class="paragraph"> </div>

<ul class="doclist">
<li> The constructor <span class="inlinecode"><span class="id" type="var">S</span></span> is <i>injective</i>.  That is, the only way we can
      have <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> is if <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>.

<div class="paragraph"> </div>


</li>
<li> The constructors <span class="inlinecode"><span class="id" type="var">O</span></span> and <span class="inlinecode"><span class="id" type="var">S</span></span> are <i>disjoint</i>.  That is, <span class="inlinecode"><span class="id" type="var">O</span></span> is not
      equal to <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> for any <span class="inlinecode"><span class="id" type="var">n</span></span>. 
</li>
</ul>

<div class="paragraph"> </div>

 Similar principles apply to all inductively defined types: all
    constructors are injective, and the values built from distinct
    constructors are never equal.  For lists, the <span class="inlinecode"><span class="id" type="var">cons</span></span> constructor is
    injective and <span class="inlinecode"><span class="id" type="var">nil</span></span> is different from every non-empty list.  For
    booleans, <span class="inlinecode"><span class="id" type="var">true</span></span> and <span class="inlinecode"><span class="id" type="var">false</span></span> are unequal.  (Since neither <span class="inlinecode"><span class="id" type="var">true</span></span>
    nor <span class="inlinecode"><span class="id" type="var">false</span></span> take any arguments, their injectivity is not an issue.) 
<div class="paragraph"> </div>

 Coq provides a tactic called <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> that allows us to exploit
    these principles in proofs.

<div class="paragraph"> </div>

    The <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> tactic is used like this.  Suppose <span class="inlinecode"><span class="id" type="var">H</span></span> is a
    hypothesis in the context (or a previously proven lemma) of the
    form

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">c</span>&nbsp;<span class="id" type="var">a1</span>&nbsp;<span class="id" type="var">a2</span>&nbsp;... <span class="id" type="var">an</span>&nbsp;=&nbsp;<span class="id" type="var">d</span>&nbsp;<span class="id" type="var">b1</span>&nbsp;<span class="id" type="var">b2</span>&nbsp;... <span class="id" type="var">bm</span>
<div class="paragraph"> </div>

</div>
    for some constructors <span class="inlinecode"><span class="id" type="var">c</span></span> and <span class="inlinecode"><span class="id" type="var">d</span></span> and arguments <span class="inlinecode"><span class="id" type="var">a1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" type="var">an</span></span> and
    <span class="inlinecode"><span class="id" type="var">b1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" type="var">bm</span></span>.  Then <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> instructs Coq to "invert" this
    equality to extract the information it contains about these terms:

<div class="paragraph"> </div>

<ul class="doclist">
<li> If <span class="inlinecode"><span class="id" type="var">c</span></span> and <span class="inlinecode"><span class="id" type="var">d</span></span> are the same constructor, then we know, by the
      injectivity of this constructor, that <span class="inlinecode"><span class="id" type="var">a1</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">b1</span></span>, <span class="inlinecode"><span class="id" type="var">a2</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">b2</span></span>,
      etc.; <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> adds these facts to the context, and tries
      to use them to rewrite the goal.

<div class="paragraph"> </div>


</li>
<li> If <span class="inlinecode"><span class="id" type="var">c</span></span> and <span class="inlinecode"><span class="id" type="var">d</span></span> are different constructors, then the hypothesis
      <span class="inlinecode"><span class="id" type="var">H</span></span> is contradictory.  That is, a false assumption has crept
      into the context, and this means that any goal whatsoever is
      provable!  In this case, <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> marks the current goal as
      completed and pops it off the goal stack. 
</li>
</ul>

<div class="paragraph"> </div>

 The <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> tactic is probably easier to understand by
    seeing it in action than from general descriptions like the above.
    Below you will find example theorems that demonstrate the use of
    <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> and exercises to test your understanding. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">eq_add_S</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">S</span> <span class="id" type="var">n</span> = <span class="id" type="var">S</span> <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">n</span> = <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">silly4</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">n</span>] = [<span class="id" type="var">m</span>] <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">n</span> = <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
As a convenience, the <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> tactic can also
    destruct equalities between complex values, binding
    multiple variables as it goes. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">silly5</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">n</span>;<span class="id" type="var">m</span>] = [<span class="id" type="var">o</span>;<span class="id" type="var">o</span>] <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">n</span>] = [<span class="id" type="var">m</span>].<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab163"></a><h4 class="section">Exercise: 1 star (sillyex1)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Example</span> <span class="id" type="var">sillyex1</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span> : <span class="id" type="var">X</span>) (<span class="id" type="var">l</span> <span class="id" type="var">j</span> : <span class="id" type="var">list</span> <span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">x</span> :: <span class="id" type="var">y</span> :: <span class="id" type="var">l</span> = <span class="id" type="var">z</span> :: <span class="id" type="var">j</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">y</span> :: <span class="id" type="var">l</span> = <span class="id" type="var">x</span> :: <span class="id" type="var">j</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">x</span> = <span class="id" type="var">y</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">silly6</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">S</span> <span class="id" type="var">n</span> = <span class="id" type="var">O</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 + 2 = 5.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">contra</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">contra</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">silly7</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">false</span> = <span class="id" type="var">true</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">n</span>] = [<span class="id" type="var">m</span>].<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">contra</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">contra</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab164"></a><h4 class="section">Exercise: 1 star (sillyex2)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Example</span> <span class="id" type="var">sillyex2</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span> : <span class="id" type="var">X</span>) (<span class="id" type="var">l</span> <span class="id" type="var">j</span> : <span class="id" type="var">list</span> <span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">x</span> :: <span class="id" type="var">y</span> :: <span class="id" type="var">l</span> = [] <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">y</span> :: <span class="id" type="var">l</span> = <span class="id" type="var">z</span> :: <span class="id" type="var">j</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">x</span> = <span class="id" type="var">z</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 While the injectivity of constructors allows us to reason
    <span class="inlinecode"><span style="font-family: arial;">&forall;</span></span> <span class="inlinecode">(<span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span>),</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>, the reverse direction of
    the implication is an instance of a more general fact about
    constructors and functions, which we will often find useful: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="tactic">f_equal</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">f</span>: <span class="id" type="var">A</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">B</span>) (<span class="id" type="var">x</span> <span class="id" type="var">y</span>: <span class="id" type="var">A</span>), <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">x</span> = <span class="id" type="var">y</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">f</span> <span class="id" type="var">x</span> = <span class="id" type="var">f</span> <span class="id" type="var">y</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">f</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab165"></a><h4 class="section">Exercise: 2 stars, optional (practice)</h4>
 A couple more nontrivial but not-too-complicated proofs to work
    together in class, or for you to work as exercises. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">beq_nat_0_l</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">beq_nat</span> 0 <span class="id" type="var">n</span> = <span class="id" type="var">true</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">n</span> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">beq_nat_0_r</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">beq_nat</span> <span class="id" type="var">n</span> 0 = <span class="id" type="var">true</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">n</span> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab166"></a><h1 class="section">Using Tactics on Hypotheses</h1>

<div class="paragraph"> </div>

 By default, most tactics work on the goal formula and leave
    the context unchanged.  However, most tactics also have a variant
    that performs a similar operation on a statement in the context.

<div class="paragraph"> </div>

    For example, the tactic <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> performs simplification in
    the hypothesis named <span class="inlinecode"><span class="id" type="var">H</span></span> in the context. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">S_inj</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>) (<span class="id" type="var">b</span> : <span class="id" type="var">bool</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">beq_nat</span> (<span class="id" type="var">S</span> <span class="id" type="var">n</span>) (<span class="id" type="var">S</span> <span class="id" type="var">m</span>) = <span class="id" type="var">b</span>  <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">beq_nat</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> = <span class="id" type="var">b</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">b</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Similarly, the tactic <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">L</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> matches some
    conditional statement <span class="inlinecode"><span class="id" type="var">L</span></span> (of the form <span class="inlinecode"><span class="id" type="var">L1</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">L2</span></span>, say) against a
    hypothesis <span class="inlinecode"><span class="id" type="var">H</span></span> in the context.  However, unlike ordinary
    <span class="inlinecode"><span class="id" type="tactic">apply</span></span> (which rewrites a goal matching <span class="inlinecode"><span class="id" type="var">L2</span></span> into a subgoal <span class="inlinecode"><span class="id" type="var">L1</span></span>),
    <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">L</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> matches <span class="inlinecode"><span class="id" type="var">H</span></span> against <span class="inlinecode"><span class="id" type="var">L1</span></span> and, if successful,
    replaces it with <span class="inlinecode"><span class="id" type="var">L2</span></span>.

<div class="paragraph"> </div>

    In other words, <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">L</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span> gives us a form of "forward
    reasoning" &mdash; from <span class="inlinecode"><span class="id" type="var">L1</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">L2</span></span> and a hypothesis matching <span class="inlinecode"><span class="id" type="var">L1</span></span>, it
    gives us a hypothesis matching <span class="inlinecode"><span class="id" type="var">L2</span></span>.  By contrast, <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">L</span></span> is
    "backward reasoning" &mdash; it says that if we know <span class="inlinecode"><span class="id" type="var">L1</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">L2</span></span> and we
    are trying to prove <span class="inlinecode"><span class="id" type="var">L2</span></span>, it suffices to prove <span class="inlinecode"><span class="id" type="var">L1</span></span>.  

<div class="paragraph"> </div>

    Here is a variant of a proof from above, using forward reasoning
    throughout instead of backward reasoning. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">silly3'</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;(<span class="id" type="var">beq_nat</span> <span class="id" type="var">n</span> 5 = <span class="id" type="var">true</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">beq_nat</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">n</span>)) 7 = <span class="id" type="var">true</span>) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">true</span> = <span class="id" type="var">beq_nat</span> <span class="id" type="var">n</span> 5  <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">true</span> = <span class="id" type="var">beq_nat</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">n</span>)) 7.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">eq</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">symmetry</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">eq</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">symmetry</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Forward reasoning starts from what is <i>given</i> (premises,
    previously proven theorems) and iteratively draws conclusions from
    them until the goal is reached.  Backward reasoning starts from
    the <i>goal</i>, and iteratively reasons about what would imply the
    goal, until premises or previously proven theorems are reached.
    If you've seen informal proofs before (for example, in a math or
    computer science class), they probably used forward reasoning.  In
    general, Coq tends to favor backward reasoning, but in some
    situations the forward style can be easier to use or to think
    about.  
<div class="paragraph"> </div>

<a name="lab167"></a><h4 class="section">Exercise: 3 stars (plus_n_n_injective)</h4>
 Practice using "in" variants in this exercise. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_n_n_injective</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">n</span> + <span class="id" type="var">n</span> = <span class="id" type="var">m</span> + <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">n</span> = <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Hint:&nbsp;use&nbsp;the&nbsp;plus_n_Sm&nbsp;lemma&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab168"></a><h1 class="section">Varying the Induction Hypothesis</h1>

<div class="paragraph"> </div>

 Sometimes it is important to control the exact form of the
    induction hypothesis when carrying out inductive proofs in Coq.
    In particular, we need to be careful about which of the
    assumptions we move (using <span class="inlinecode"><span class="id" type="tactic">intros</span></span>) from the goal to the context
    before invoking the <span class="inlinecode"><span class="id" type="tactic">induction</span></span> tactic.  For example, suppose 
    we want to show that the <span class="inlinecode"><span class="id" type="var">double</span></span> function is injective &mdash; i.e., 
    that it always maps different arguments to different results:  

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Theorem</span>&nbsp;<span class="id" type="var">double_injective</span>:&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>&nbsp;<span class="id" type="var">m</span>,&nbsp;<span class="id" type="var">double</span>&nbsp;<span class="id" type="var">n</span>&nbsp;=&nbsp;<span class="id" type="var">double</span>&nbsp;<span class="id" type="var">m</span>&nbsp;<span style="font-family: arial;">&rarr;</span>&nbsp;<span class="id" type="var">n</span>&nbsp;=&nbsp;<span class="id" type="var">m</span>.
<div class="paragraph"> </div>

</div>
    The way we <i>start</i> this proof is a little bit delicate: if we 
    begin it with

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span>&nbsp;<span class="id" type="var">n</span>. <span class="id" type="tactic">induction</span>&nbsp;<span class="id" type="var">n</span>.
<div class="paragraph"> </div>

</div>
    all is well.  But if we begin it with

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span class="id" type="var">m</span>. <span class="id" type="tactic">induction</span>&nbsp;<span class="id" type="var">n</span>.
<div class="paragraph"> </div>

</div>
    we get stuck in the middle of the inductive case... 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">double_injective_FAILED</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">double</span> <span class="id" type="var">n</span> = <span class="id" type="var">double</span> <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">n</span> = <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span>].<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "n = O". <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">m</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">m'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "m = O". <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "m = S m'". <span class="id" type="tactic">inversion</span> <span class="id" type="var">eq</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "n = S n'". <span class="id" type="tactic">intros</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">m</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">m'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "m = O". <span class="id" type="tactic">inversion</span> <span class="id" type="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "m = S m'". <span class="id" type="tactic">apply</span> <span class="id" type="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Here&nbsp;we&nbsp;are&nbsp;stuck.&nbsp;&nbsp;The&nbsp;induction&nbsp;hypothesis,&nbsp;<span class="inlinecode"><span class="id" type="var">IHn'</span></span>,&nbsp;does<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;not&nbsp;give&nbsp;us&nbsp;<span class="inlinecode"><span class="id" type="var">n'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m'</span></span>&nbsp;--&nbsp;there&nbsp;is&nbsp;an&nbsp;extra&nbsp;<span class="inlinecode"><span class="id" type="var">S</span></span>&nbsp;in&nbsp;the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;way&nbsp;--&nbsp;so&nbsp;the&nbsp;goal&nbsp;is&nbsp;not&nbsp;provable.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
What went wrong? 
<div class="paragraph"> </div>

 The problem is that, at the point we invoke the induction
    hypothesis, we have already introduced <span class="inlinecode"><span class="id" type="var">m</span></span> into the context &mdash; 
    intuitively, we have told Coq, "Let's consider some particular
    <span class="inlinecode"><span class="id" type="var">n</span></span> and <span class="inlinecode"><span class="id" type="var">m</span></span>..." and we now have to prove that, if <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span>
    <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> for <i>this particular</i> <span class="inlinecode"><span class="id" type="var">n</span></span> and <span class="inlinecode"><span class="id" type="var">m</span></span>, then <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>.

<div class="paragraph"> </div>

    The next tactic, <span class="inlinecode"><span class="id" type="tactic">induction</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> says to Coq: We are going to show
    the goal by induction on <span class="inlinecode"><span class="id" type="var">n</span></span>.  That is, we are going to prove that
    the proposition

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>  =  "if <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span>, then <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>"

</li>
</ul>

<div class="paragraph"> </div>

    holds for all <span class="inlinecode"><span class="id" type="var">n</span></span> by showing

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">O</span></span>              

<div class="paragraph"> </div>

         (i.e., "if <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">O</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> then <span class="inlinecode"><span class="id" type="var">O</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>")

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span style="font-family: arial;">&rarr;</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span>  

<div class="paragraph"> </div>

        (i.e., "if <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> then <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>" implies "if
        <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> then <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>").

</li>
</ul>

<div class="paragraph"> </div>

    If we look closely at the second statement, it is saying something
    rather strange: it says that, for a <i>particular</i> <span class="inlinecode"><span class="id" type="var">m</span></span>, if we know

<div class="paragraph"> </div>

<ul class="doclist">
<li> "if <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> then <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>"

</li>
</ul>

<div class="paragraph"> </div>

    then we can prove

<div class="paragraph"> </div>

<ul class="doclist">
<li> "if <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> then <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>".

</li>
</ul>

<div class="paragraph"> </div>

    To see why this is strange, let's think of a particular <span class="inlinecode"><span class="id" type="var">m</span></span> &mdash;
    say, <span class="inlinecode">5</span>.  The statement is then saying that, if we know

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">Q</span></span> = "if <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">10</span> then <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">5</span>"

</li>
</ul>

<div class="paragraph"> </div>

    then we can prove

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">R</span></span> = "if <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode">10</span> then <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">5</span>".

</li>
</ul>

<div class="paragraph"> </div>

    But knowing <span class="inlinecode"><span class="id" type="var">Q</span></span> doesn't give us any help with proving <span class="inlinecode"><span class="id" type="var">R</span></span>!  (If we
    tried to prove <span class="inlinecode"><span class="id" type="var">R</span></span> from <span class="inlinecode"><span class="id" type="var">Q</span></span>, we would say something like "Suppose
    <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode">10</span>..." but then we'd be stuck: knowing that
    <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span> is <span class="inlinecode">10</span> tells us nothing about whether <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>
    is <span class="inlinecode">10</span>, so <span class="inlinecode"><span class="id" type="var">Q</span></span> is useless at this point.) 
<div class="paragraph"> </div>

 To summarize: Trying to carry out this proof by induction on <span class="inlinecode"><span class="id" type="var">n</span></span>
    when <span class="inlinecode"><span class="id" type="var">m</span></span> is already in the context doesn't work because we are
    trying to prove a relation involving <i>every</i> <span class="inlinecode"><span class="id" type="var">n</span></span> but just a
    <i>single</i> <span class="inlinecode"><span class="id" type="var">m</span></span>. 
<div class="paragraph"> </div>

 The good proof of <span class="inlinecode"><span class="id" type="var">double_injective</span></span> leaves <span class="inlinecode"><span class="id" type="var">m</span></span> in the goal
    statement at the point where the <span class="inlinecode"><span class="id" type="tactic">induction</span></span> tactic is invoked on
    <span class="inlinecode"><span class="id" type="var">n</span></span>: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">double_injective</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">double</span> <span class="id" type="var">n</span> = <span class="id" type="var">double</span> <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">n</span> = <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span>].<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "n = O". <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">m</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">m</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">m'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "m = O". <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "m = S m'". <span class="id" type="tactic">inversion</span> <span class="id" type="var">eq</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "n = S n'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Notice&nbsp;that&nbsp;both&nbsp;the&nbsp;goal&nbsp;and&nbsp;the&nbsp;induction<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hypothesis&nbsp;have&nbsp;changed:&nbsp;the&nbsp;goal&nbsp;asks&nbsp;us&nbsp;to&nbsp;prove<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;something&nbsp;more&nbsp;general&nbsp;(i.e.,&nbsp;to&nbsp;prove&nbsp;the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;statement&nbsp;for&nbsp;_every_&nbsp;<span class="inlinecode"><span class="id" type="var">m</span></span>),&nbsp;but&nbsp;the&nbsp;IH&nbsp;is<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;correspondingly&nbsp;more&nbsp;flexible,&nbsp;allowing&nbsp;us&nbsp;to<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;choose&nbsp;any&nbsp;<span class="inlinecode"><span class="id" type="var">m</span></span>&nbsp;we&nbsp;like&nbsp;when&nbsp;we&nbsp;apply&nbsp;the&nbsp;IH.&nbsp;&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">m</span> <span class="id" type="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Now&nbsp;we&nbsp;choose&nbsp;a&nbsp;particular&nbsp;<span class="inlinecode"><span class="id" type="var">m</span></span>&nbsp;and&nbsp;introduce&nbsp;the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assumption&nbsp;that&nbsp;<span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span>.&nbsp;&nbsp;Since&nbsp;we<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;are&nbsp;doing&nbsp;a&nbsp;case&nbsp;analysis&nbsp;on&nbsp;<span class="inlinecode"><span class="id" type="var">n</span></span>,&nbsp;we&nbsp;need&nbsp;a&nbsp;case<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;analysis&nbsp;on&nbsp;<span class="inlinecode"><span class="id" type="var">m</span></span>&nbsp;to&nbsp;keep&nbsp;the&nbsp;two&nbsp;"in&nbsp;sync."&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">m</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">m'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "m = O".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;The&nbsp;0&nbsp;case&nbsp;is&nbsp;trivial&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "m = S m'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;At&nbsp;this&nbsp;point,&nbsp;since&nbsp;we&nbsp;are&nbsp;in&nbsp;the&nbsp;second<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;branch&nbsp;of&nbsp;the&nbsp;<span class="inlinecode"><span class="id" type="tactic">destruct</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span>,&nbsp;the&nbsp;<span class="inlinecode"><span class="id" type="var">m'</span></span>&nbsp;mentioned<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;the&nbsp;context&nbsp;at&nbsp;this&nbsp;point&nbsp;is&nbsp;actually&nbsp;the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;predecessor&nbsp;of&nbsp;the&nbsp;one&nbsp;we&nbsp;started&nbsp;out&nbsp;talking<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;about.&nbsp;&nbsp;Since&nbsp;we&nbsp;are&nbsp;also&nbsp;in&nbsp;the&nbsp;<span class="inlinecode"><span class="id" type="var">S</span></span>&nbsp;branch&nbsp;of<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;induction,&nbsp;this&nbsp;is&nbsp;perfect:&nbsp;if&nbsp;we<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instantiate&nbsp;the&nbsp;generic&nbsp;<span class="inlinecode"><span class="id" type="var">m</span></span>&nbsp;in&nbsp;the&nbsp;IH&nbsp;with&nbsp;the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="inlinecode"><span class="id" type="var">m'</span></span>&nbsp;that&nbsp;we&nbsp;are&nbsp;talking&nbsp;about&nbsp;right&nbsp;now&nbsp;(this<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instantiation&nbsp;is&nbsp;performed&nbsp;automatically&nbsp;by<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="inlinecode"><span class="id" type="tactic">apply</span></span>),&nbsp;then&nbsp;<span class="inlinecode"><span class="id" type="var">IHn'</span></span>&nbsp;gives&nbsp;us&nbsp;exactly&nbsp;what&nbsp;we<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;need&nbsp;to&nbsp;finish&nbsp;the&nbsp;proof.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">IHn'</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
What this teaches us is that we need to be careful about using
    induction to try to prove something too specific: If we're proving
    a property of <span class="inlinecode"><span class="id" type="var">n</span></span> and <span class="inlinecode"><span class="id" type="var">m</span></span> by induction on <span class="inlinecode"><span class="id" type="var">n</span></span>, we may need to
    leave <span class="inlinecode"><span class="id" type="var">m</span></span> generic. 
<div class="paragraph"> </div>

 The proof of this theorem (left as an exercise) has to be treated similarly: 
<div class="paragraph"> </div>

<a name="lab169"></a><h4 class="section">Exercise: 2 stars (beq_nat_true)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">beq_nat_true</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">beq_nat</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> = <span class="id" type="var">true</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">n</span> = <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab170"></a><h4 class="section">Exercise: 2 stars, advanced (beq_nat_true_informal)</h4>
 Give a careful informal proof of <span class="inlinecode"><span class="id" type="var">beq_nat_true</span></span>, being as explicit
    as possible about quantifiers. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 The strategy of doing fewer <span class="inlinecode"><span class="id" type="tactic">intros</span></span> before an <span class="inlinecode"><span class="id" type="tactic">induction</span></span> doesn't
    always work directly; sometimes a little <i>rearrangement</i> of
    quantified variables is needed.  Suppose, for example, that we
    wanted to prove <span class="inlinecode"><span class="id" type="var">double_injective</span></span> by induction on <span class="inlinecode"><span class="id" type="var">m</span></span> instead of
    <span class="inlinecode"><span class="id" type="var">n</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">double_injective_take2_FAILED</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">double</span> <span class="id" type="var">n</span> = <span class="id" type="var">double</span> <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">n</span> = <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">m</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">m'</span>].<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "m = O". <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "n = O". <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "n = S n'". <span class="id" type="tactic">inversion</span> <span class="id" type="var">eq</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "m = S m'". <span class="id" type="tactic">intros</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "n = O". <span class="id" type="tactic">inversion</span> <span class="id" type="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "n = S n'". <span class="id" type="tactic">apply</span> <span class="id" type="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Stuck&nbsp;again&nbsp;here,&nbsp;just&nbsp;like&nbsp;before.&nbsp;*)</span><br/>
<span class="id" type="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
The problem is that, to do induction on <span class="inlinecode"><span class="id" type="var">m</span></span>, we must first
    introduce <span class="inlinecode"><span class="id" type="var">n</span></span>.  (If we simply say <span class="inlinecode"><span class="id" type="tactic">induction</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> without
    introducing anything first, Coq will automatically introduce
    <span class="inlinecode"><span class="id" type="var">n</span></span> for us!)   
<div class="paragraph"> </div>

 What can we do about this?  One possibility is to rewrite the
    statement of the lemma so that <span class="inlinecode"><span class="id" type="var">m</span></span> is quantified before <span class="inlinecode"><span class="id" type="var">n</span></span>.  This
    will work, but it's not nice: We don't want to have to mangle the
    statements of lemmas to fit the needs of a particular strategy for
    proving them &mdash; we want to state them in the most clear and
    natural way. 
<div class="paragraph"> </div>

  What we can do instead is to first introduce all the
    quantified variables and then <i>re-generalize</i> one or more of
    them, taking them out of the context and putting them back at
    the beginning of the goal.  The <span class="inlinecode"><span class="id" type="tactic">generalize</span></span> <span class="inlinecode"><span class="id" type="tactic">dependent</span></span> tactic
    does this. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">double_injective_take2</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">double</span> <span class="id" type="var">n</span> = <span class="id" type="var">double</span> <span class="id" type="var">m</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">n</span> = <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;<span class="inlinecode"><span class="id" type="var">n</span></span>&nbsp;and&nbsp;<span class="inlinecode"><span class="id" type="var">m</span></span>&nbsp;are&nbsp;both&nbsp;in&nbsp;the&nbsp;context&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">generalize</span> <span class="id" type="tactic">dependent</span> <span class="id" type="var">n</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Now&nbsp;<span class="inlinecode"><span class="id" type="var">n</span></span>&nbsp;is&nbsp;back&nbsp;in&nbsp;the&nbsp;goal&nbsp;and&nbsp;we&nbsp;can&nbsp;do&nbsp;induction&nbsp;on<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="inlinecode"><span class="id" type="var">m</span></span>&nbsp;and&nbsp;get&nbsp;a&nbsp;sufficiently&nbsp;general&nbsp;IH.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">m</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">m'</span>].<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "m = O". <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "n = O". <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "n = S n'". <span class="id" type="tactic">inversion</span> <span class="id" type="var">eq</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "m = S m'". <span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "n = O". <span class="id" type="tactic">inversion</span> <span class="id" type="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "n = S n'". <span class="id" type="tactic">apply</span> <span class="id" type="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">IHm'</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Let's look at an informal proof of this theorem.  Note that
    the proposition we prove by induction leaves <span class="inlinecode"><span class="id" type="var">n</span></span> quantified,
    corresponding to the use of generalize dependent in our formal
    proof.

<div class="paragraph"> </div>

<i>Theorem</i>: For any nats <span class="inlinecode"><span class="id" type="var">n</span></span> and <span class="inlinecode"><span class="id" type="var">m</span></span>, if <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span>, then
  <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>.

<div class="paragraph"> </div>

<i>Proof</i>: Let <span class="inlinecode"><span class="id" type="var">m</span></span> be a <span class="inlinecode"><span class="id" type="var">nat</span></span>. We prove by induction on <span class="inlinecode"><span class="id" type="var">m</span></span> that, for
  any <span class="inlinecode"><span class="id" type="var">n</span></span>, if <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> then <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>.

<div class="paragraph"> </div>

<ul class="doclist">
<li> First, suppose <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>, and suppose <span class="inlinecode"><span class="id" type="var">n</span></span> is a number such
    that <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span>.  We must show that <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>.

<div class="paragraph"> </div>

    Since <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>, by the definition of <span class="inlinecode"><span class="id" type="var">double</span></span> we have <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span>
    <span class="inlinecode">0</span>.  There are two cases to consider for <span class="inlinecode"><span class="id" type="var">n</span></span>.  If <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> we are
    done, since this is what we wanted to show.  Otherwise, if <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span>
    <span class="inlinecode"><span class="id" type="var">n'</span></span> for some <span class="inlinecode"><span class="id" type="var">n'</span></span>, we derive a contradiction: by the definition of
    <span class="inlinecode"><span class="id" type="var">double</span></span> we would have <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">n'</span>))</span>, but this
    contradicts the assumption that <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>.

<div class="paragraph"> </div>


</li>
<li> Otherwise, suppose <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">m'</span></span> and that <span class="inlinecode"><span class="id" type="var">n</span></span> is again a number such
    that <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span>.  We must show that <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">m'</span></span>, with
    the induction hypothesis that for every number <span class="inlinecode"><span class="id" type="var">s</span></span>, if <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">s</span></span> <span class="inlinecode">=</span>
    <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">m'</span></span> then <span class="inlinecode"><span class="id" type="var">s</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m'</span></span>.

<div class="paragraph"> </div>

    By the fact that <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">m'</span></span> and the definition of <span class="inlinecode"><span class="id" type="var">double</span></span>, we
    have <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">m'</span>))</span>.  There are two cases to
    consider for <span class="inlinecode"><span class="id" type="var">n</span></span>.

<div class="paragraph"> </div>

    If <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>, then by definition <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>, a contradiction.
    Thus, we may assume that <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> for some <span class="inlinecode"><span class="id" type="var">n'</span></span>, and again by
    the definition of <span class="inlinecode"><span class="id" type="var">double</span></span> we have <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">n'</span>))</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span>
    <span class="inlinecode">(<span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">m'</span>))</span>, which implies by inversion that <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">double</span></span>
    <span class="inlinecode"><span class="id" type="var">m'</span></span>.

<div class="paragraph"> </div>

    Instantiating the induction hypothesis with <span class="inlinecode"><span class="id" type="var">n'</span></span> thus allows us to
    conclude that <span class="inlinecode"><span class="id" type="var">n'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m'</span></span>, and it follows immediately that <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span>
    <span class="inlinecode"><span class="id" type="var">m'</span></span>.  Since <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">n</span></span> and <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">m'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>, this is just what we wanted
    to show. <font size=-2>&#9744;</font> 
</li>
</ul>

<div class="paragraph"> </div>

 Here's another illustration of <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> and using an
    appropriately general induction hypothesis.  This is a slightly
    roundabout way of stating a fact that we have already proved
    above.  The extra equalities force us to do a little more
    equational reasoning and exercise some of the tactics we've seen
    recently. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">length_snoc'</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">v</span> : <span class="id" type="var">X</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">l</span> : <span class="id" type="var">list</span> <span class="id" type="var">X</span>) (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">length</span> <span class="id" type="var">l</span> = <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">length</span> (<span class="id" type="var">snoc</span> <span class="id" type="var">l</span> <span class="id" type="var">v</span>) = <span class="id" type="var">S</span> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">X</span> <span class="id" type="var">v</span> <span class="id" type="var">l</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">v'</span> <span class="id" type="var">l'</span>].<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "l = []".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&larr;</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">reflexivity</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "l = v' :: l'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "n = 0". <span class="id" type="tactic">inversion</span> <span class="id" type="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "n = S n'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="tactic">f_equal</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">IHl'</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
It might be tempting to start proving the above theorem
    by introducing <span class="inlinecode"><span class="id" type="var">n</span></span> and <span class="inlinecode"><span class="id" type="var">eq</span></span> at the outset.  However, this leads
    to an induction hypothesis that is not strong enough.  Compare
    the above to the following (aborted) attempt: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">length_snoc_bad</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">v</span> : <span class="id" type="var">X</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">l</span> : <span class="id" type="var">list</span> <span class="id" type="var">X</span>) (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">length</span> <span class="id" type="var">l</span> = <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">length</span> (<span class="id" type="var">snoc</span> <span class="id" type="var">l</span> <span class="id" type="var">v</span>) = <span class="id" type="var">S</span> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">X</span> <span class="id" type="var">v</span> <span class="id" type="var">l</span> <span class="id" type="var">n</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">v'</span> <span class="id" type="var">l'</span>].<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "l = []".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&larr;</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">reflexivity</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "l = v' :: l'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "n = 0". <span class="id" type="tactic">inversion</span> <span class="id" type="var">eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "n = S n'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="tactic">f_equal</span>. <span class="id" type="keyword">Abort</span>. <span class="comment">(*&nbsp;apply&nbsp;IHl'.&nbsp;*)</span> <span class="comment">(*&nbsp;The&nbsp;IH&nbsp;doesn't&nbsp;apply!&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
As in the double examples, the problem is that by
    introducing <span class="inlinecode"><span class="id" type="var">n</span></span> before doing induction on <span class="inlinecode"><span class="id" type="var">l</span></span>, the induction
    hypothesis is specialized to one particular natural number, namely
    <span class="inlinecode"><span class="id" type="var">n</span></span>.  In the induction case, however, we need to be able to use
    the induction hypothesis on some other natural number <span class="inlinecode"><span class="id" type="var">n'</span></span>.
    Retaining the more general form of the induction hypothesis thus
    gives us more flexibility.

<div class="paragraph"> </div>

    In general, a good rule of thumb is to make the induction hypothesis
    as general as possible. 
<div class="paragraph"> </div>

<a name="lab171"></a><h4 class="section">Exercise: 3 stars (gen_dep_practice)</h4>

<div class="paragraph"> </div>

 Prove this by induction on <span class="inlinecode"><span class="id" type="var">l</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">index_after_last</span>: <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>) (<span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">l</span> : <span class="id" type="var">list</span> <span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">length</span> <span class="id" type="var">l</span> = <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">index</span> <span class="id" type="var">n</span> <span class="id" type="var">l</span> = <span class="id" type="var">None</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab172"></a><h4 class="section">Exercise: 3 stars, advanced, optional (index_after_last_informal)</h4>
 Write an informal proof corresponding to your Coq proof
    of <span class="inlinecode"><span class="id" type="var">index_after_last</span></span>:

<div class="paragraph"> </div>

     <i>Theorem</i>: For all sets <span class="inlinecode"><span class="id" type="var">X</span></span>, lists <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span>, and numbers
      <span class="inlinecode"><span class="id" type="var">n</span></span>, if <span class="inlinecode"><span class="id" type="var">length</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">n</span></span> then <span class="inlinecode"><span class="id" type="var">index</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">None</span></span>.

<div class="paragraph"> </div>

     <i>Proof</i>:
     <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
<font size=-2>&#9744;</font>

<div class="paragraph"> </div>

<a name="lab173"></a><h4 class="section">Exercise: 3 stars, optional (gen_dep_practice_more)</h4>
 Prove this by induction on <span class="inlinecode"><span class="id" type="var">l</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">length_snoc'''</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>) (<span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">v</span> : <span class="id" type="var">X</span>) (<span class="id" type="var">l</span> : <span class="id" type="var">list</span> <span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">length</span> <span class="id" type="var">l</span> = <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">length</span> (<span class="id" type="var">snoc</span> <span class="id" type="var">l</span> <span class="id" type="var">v</span>) = <span class="id" type="var">S</span> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab174"></a><h4 class="section">Exercise: 3 stars, optional (app_length_cons)</h4>
 Prove this by induction on <span class="inlinecode"><span class="id" type="var">l1</span></span>, without using <span class="inlinecode"><span class="id" type="var">app_length</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">app_length_cons</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">l1</span> <span class="id" type="var">l2</span> : <span class="id" type="var">list</span> <span class="id" type="var">X</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">x</span> : <span class="id" type="var">X</span>) (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">length</span> (<span class="id" type="var">l1</span> ++ (<span class="id" type="var">x</span> :: <span class="id" type="var">l2</span>)) = <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">S</span> (<span class="id" type="var">length</span> (<span class="id" type="var">l1</span> ++ <span class="id" type="var">l2</span>)) = <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab175"></a><h4 class="section">Exercise: 4 stars, optional (app_length_twice)</h4>
 Prove this by induction on <span class="inlinecode"><span class="id" type="var">l</span></span>, without using app_length. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">app_length_twice</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) (<span class="id" type="var">n</span>:<span class="id" type="var">nat</span>) (<span class="id" type="var">l</span>:<span class="id" type="var">list</span> <span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">length</span> <span class="id" type="var">l</span> = <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">length</span> (<span class="id" type="var">l</span> ++ <span class="id" type="var">l</span>) = <span class="id" type="var">n</span> + <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab176"></a><h4 class="section">Exercise: 3 stars, optional (double_induction)</h4>
 Prove the following principle of induction over two naturals. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">double_induction</span>: <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">P</span> : <span class="id" type="var">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">nat</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="keyword">Prop</span>), <br/>
&nbsp;&nbsp;<span class="id" type="var">P</span> 0 0 <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span><span class="id" type="var">m</span>, <span class="id" type="var">P</span> <span class="id" type="var">m</span> 0 <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">P</span> (<span class="id" type="var">S</span> <span class="id" type="var">m</span>) 0) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span>, <span class="id" type="var">P</span> 0 <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">P</span> 0 (<span class="id" type="var">S</span> <span class="id" type="var">n</span>)) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;(<span style="font-family: arial;">&forall;</span><span class="id" type="var">m</span> <span class="id" type="var">n</span>, <span class="id" type="var">P</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">P</span> (<span class="id" type="var">S</span> <span class="id" type="var">m</span>) (<span class="id" type="var">S</span> <span class="id" type="var">n</span>)) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span><span class="id" type="var">m</span> <span class="id" type="var">n</span>, <span class="id" type="var">P</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab177"></a><h1 class="section">Using <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> on Compound Expressions</h1>

<div class="paragraph"> </div>

 We have seen many examples where the <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> tactic is
    used to perform case analysis of the value of some variable.  But
    sometimes we need to reason by cases on the result of some
    <i>expression</i>.  We can also do this with <span class="inlinecode"><span class="id" type="tactic">destruct</span></span>.

<div class="paragraph"> </div>

    Here are some examples: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">sillyfun</span> (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="var">beq_nat</span> <span class="id" type="var">n</span> 3 <span class="id" type="keyword">then</span> <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="keyword">if</span> <span class="id" type="var">beq_nat</span> <span class="id" type="var">n</span> 5 <span class="id" type="keyword">then</span> <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="var">false</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">sillyfun_false</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;<span class="id" type="var">sillyfun</span> <span class="id" type="var">n</span> = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">unfold</span> <span class="id" type="var">sillyfun</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> (<span class="id" type="var">beq_nat</span> <span class="id" type="var">n</span> 3).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "beq_nat n 3 = true". <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "beq_nat n 3 = false". <span class="id" type="tactic">destruct</span> (<span class="id" type="var">beq_nat</span> <span class="id" type="var">n</span> 5).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "beq_nat n 5 = true". <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "beq_nat n 5 = false". <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
After unfolding <span class="inlinecode"><span class="id" type="var">sillyfun</span></span> in the above proof, we find that
    we are stuck on <span class="inlinecode"><span class="id" type="keyword">if</span></span> <span class="inlinecode">(<span class="id" type="var">beq_nat</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">3)</span> <span class="inlinecode"><span class="id" type="keyword">then</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" type="keyword">else</span></span> <span class="inlinecode">...</span>.  Well,
    either <span class="inlinecode"><span class="id" type="var">n</span></span> is equal to <span class="inlinecode">3</span> or it isn't, so we use <span class="inlinecode"><span class="id" type="tactic">destruct</span></span>
    <span class="inlinecode">(<span class="id" type="var">beq_nat</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">3)</span> to let us reason about the two cases. 

<div class="paragraph"> </div>

    In general, the <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> tactic can be used to perform case
    analysis of the results of arbitrary computations.  If <span class="inlinecode"><span class="id" type="var">e</span></span> is an
    expression whose type is some inductively defined type <span class="inlinecode"><span class="id" type="var">T</span></span>, then,
    for each constructor <span class="inlinecode"><span class="id" type="var">c</span></span> of <span class="inlinecode"><span class="id" type="var">T</span></span>, <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> <span class="inlinecode"><span class="id" type="var">e</span></span> generates a subgoal
    in which all occurrences of <span class="inlinecode"><span class="id" type="var">e</span></span> (in the goal and in the context)
    are replaced by <span class="inlinecode"><span class="id" type="var">c</span></span>.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<a name="lab178"></a><h4 class="section">Exercise: 1 star (override_shadow)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">override_shadow</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) <span class="id" type="var">x1</span> <span class="id" type="var">x2</span> <span class="id" type="var">k1</span> <span class="id" type="var">k2</span> (<span class="id" type="var">f</span> : <span class="id" type="var">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;(<span class="id" type="var">override</span> (<span class="id" type="var">override</span> <span class="id" type="var">f</span> <span class="id" type="var">k1</span> <span class="id" type="var">x2</span>) <span class="id" type="var">k1</span> <span class="id" type="var">x1</span>) <span class="id" type="var">k2</span> = (<span class="id" type="var">override</span> <span class="id" type="var">f</span> <span class="id" type="var">k1</span> <span class="id" type="var">x1</span>) <span class="id" type="var">k2</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab179"></a><h4 class="section">Exercise: 3 stars, optional (combine_split)</h4>
 Complete the proof below 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">combine_split</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">X</span> <span class="id" type="var">Y</span> (<span class="id" type="var">l</span> : <span class="id" type="var">list</span> (<span class="id" type="var">X</span> × <span class="id" type="var">Y</span>)) <span class="id" type="var">l1</span> <span class="id" type="var">l2</span>,<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span> <span class="id" type="var">l</span> = (<span class="id" type="var">l1</span>, <span class="id" type="var">l2</span>) <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;<span class="id" type="var">combine</span> <span class="id" type="var">l1</span> <span class="id" type="var">l2</span> = <span class="id" type="var">l</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 Sometimes, doing a <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> on a compound expression (a
    non-variable) will erase information we need to complete a proof.  For example, suppose
    we define a function <span class="inlinecode"><span class="id" type="var">sillyfun1</span></span> like this: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">sillyfun1</span> (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="var">beq_nat</span> <span class="id" type="var">n</span> 3 <span class="id" type="keyword">then</span> <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="keyword">if</span> <span class="id" type="var">beq_nat</span> <span class="id" type="var">n</span> 5 <span class="id" type="keyword">then</span> <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="var">false</span>.<br/>

<br/>
</div>

<div class="doc">
And suppose that we want to convince Coq of the rather
    obvious observation that <span class="inlinecode"><span class="id" type="var">sillyfun1</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> yields <span class="inlinecode"><span class="id" type="var">true</span></span> only when <span class="inlinecode"><span class="id" type="var">n</span></span>
    is odd.  By analogy with the proofs we did with <span class="inlinecode"><span class="id" type="var">sillyfun</span></span> above,
    it is natural to start the proof like this: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">sillyfun1_odd_FAILED</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">sillyfun1</span> <span class="id" type="var">n</span> = <span class="id" type="var">true</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">oddb</span> <span class="id" type="var">n</span> = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">unfold</span> <span class="id" type="var">sillyfun1</span> <span class="id" type="keyword">in</span> <span class="id" type="var">eq</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> (<span class="id" type="var">beq_nat</span> <span class="id" type="var">n</span> 3).<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;stuck...&nbsp;*)</span><br/>
<span class="id" type="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
We get stuck at this point because the context does not
    contain enough information to prove the goal!  The problem is that
    the substitution peformed by <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> is too brutal &mdash; it threw
    away every occurrence of <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">3</span>, but we need to keep some
    memory of this expression and how it was destructed, because we
    need to be able to reason that since, in this branch of the case
    analysis, <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">3</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">true</span></span>, it must be that <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">3</span>, from
    which it follows that <span class="inlinecode"><span class="id" type="var">n</span></span> is odd.

<div class="paragraph"> </div>

    What we would really like is to substitute away all existing
    occurences of <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">3</span>, but at the same time add an equation
    to the context that records which case we are in.  The <span class="inlinecode"><span class="id" type="var">eqn</span>:</span>
    qualifier allows us to introduce such an equation (with whatever
    name we choose). 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">sillyfun1_odd</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">sillyfun1</span> <span class="id" type="var">n</span> = <span class="id" type="var">true</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">oddb</span> <span class="id" type="var">n</span> = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">eq</span>. <span class="id" type="tactic">unfold</span> <span class="id" type="var">sillyfun1</span> <span class="id" type="keyword">in</span> <span class="id" type="var">eq</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> (<span class="id" type="var">beq_nat</span> <span class="id" type="var">n</span> 3) <span class="id" type="var">eqn</span>:<span class="id" type="var">Heqe3</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Now&nbsp;we&nbsp;have&nbsp;the&nbsp;same&nbsp;state&nbsp;as&nbsp;at&nbsp;the&nbsp;point&nbsp;where&nbsp;we&nbsp;got&nbsp;stuck<br/>
&nbsp;&nbsp;&nbsp;&nbsp;above,&nbsp;except&nbsp;that&nbsp;the&nbsp;context&nbsp;contains&nbsp;an&nbsp;extra&nbsp;equality<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assumption,&nbsp;which&nbsp;is&nbsp;exactly&nbsp;what&nbsp;we&nbsp;need&nbsp;to&nbsp;make&nbsp;progress.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "e3 = true". <span class="id" type="tactic">apply</span> <span class="id" type="var">beq_nat_true</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Heqe3</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Heqe3</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "e3 = false".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;When&nbsp;we&nbsp;come&nbsp;to&nbsp;the&nbsp;second&nbsp;equality&nbsp;test&nbsp;in&nbsp;the&nbsp;body&nbsp;of&nbsp;the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;we&nbsp;are&nbsp;reasoning&nbsp;about,&nbsp;we&nbsp;can&nbsp;use&nbsp;<span class="inlinecode"><span class="id" type="var">eqn</span>:</span>&nbsp;again&nbsp;in&nbsp;the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;same&nbsp;way,&nbsp;allow&nbsp;us&nbsp;to&nbsp;finish&nbsp;the&nbsp;proof.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> (<span class="id" type="var">beq_nat</span> <span class="id" type="var">n</span> 5) <span class="id" type="var">eqn</span>:<span class="id" type="var">Heqe5</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "e5 = true".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">beq_nat_true</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Heqe5</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">Heqe5</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "e5 = false". <span class="id" type="tactic">inversion</span> <span class="id" type="var">eq</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab180"></a><h4 class="section">Exercise: 2 stars (destruct_eqn_practice)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">bool_fn_applied_thrice</span> : <br/>
&nbsp;&nbsp;<span style="font-family: arial;">&forall;</span>(<span class="id" type="var">f</span> : <span class="id" type="var">bool</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">bool</span>) (<span class="id" type="var">b</span> : <span class="id" type="var">bool</span>), <br/>
&nbsp;&nbsp;<span class="id" type="var">f</span> (<span class="id" type="var">f</span> (<span class="id" type="var">f</span> <span class="id" type="var">b</span>)) = <span class="id" type="var">f</span> <span class="id" type="var">b</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab181"></a><h4 class="section">Exercise: 2 stars (override_same)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">override_same</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) <span class="id" type="var">x1</span> <span class="id" type="var">k1</span> <span class="id" type="var">k2</span> (<span class="id" type="var">f</span> : <span class="id" type="var">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;<span class="id" type="var">f</span> <span class="id" type="var">k1</span> = <span class="id" type="var">x1</span> <span style="font-family: arial;">&rarr;</span> <br/>
&nbsp;&nbsp;(<span class="id" type="var">override</span> <span class="id" type="var">f</span> <span class="id" type="var">k1</span> <span class="id" type="var">x1</span>) <span class="id" type="var">k2</span> = <span class="id" type="var">f</span> <span class="id" type="var">k2</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab182"></a><h1 class="section">Review</h1>

<div class="paragraph"> </div>

 We've now seen a bunch of Coq's fundamental tactics.  We'll
    introduce a few more as we go along through the coming lectures,
    and later in the course we'll introduce some more powerful
    <i>automation</i> tactics that make Coq do more of the low-level work
    in many cases.  But basically we've got what we need to get work
    done.

<div class="paragraph"> </div>

    Here are the ones we've seen:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="tactic">intros</span></span>: 
        move hypotheses/variables from goal to context 

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span>:
        finish the proof (when the goal looks like <span class="inlinecode"><span class="id" type="var">e</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">e</span></span>)

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">apply</span></span>:
        prove goal using a hypothesis, lemma, or constructor

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">apply</span>...</span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span>: 
        apply a hypothesis, lemma, or constructor to a hypothesis in
        the context (forward reasoning)

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">apply</span>...</span> <span class="inlinecode"><span class="id" type="keyword">with</span>...</span>:
        explicitly specify values for variables that cannot be
        determined by pattern matching

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">simpl</span></span>:
        simplify computations in the goal 

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span>:
        ... or a hypothesis 

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span>:
        use an equality hypothesis (or lemma) to rewrite the goal 

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span>:
        ... or a hypothesis 

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">symmetry</span></span>:
        changes a goal of the form <span class="inlinecode"><span class="id" type="var">t</span>=<span class="id" type="var">u</span></span> into <span class="inlinecode"><span class="id" type="var">u</span>=<span class="id" type="var">t</span></span>

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">symmetry</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span>:
        changes a hypothesis of the form <span class="inlinecode"><span class="id" type="var">t</span>=<span class="id" type="var">u</span></span> into <span class="inlinecode"><span class="id" type="var">u</span>=<span class="id" type="var">t</span></span>

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">unfold</span></span>:
        replace a defined constant by its right-hand side in the goal 

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">unfold</span>...</span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span>:
        ... or a hypothesis  

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">destruct</span>...</span> <span class="inlinecode"><span class="id" type="keyword">as</span>...</span>:
        case analysis on values of inductively defined types 

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">destruct</span>...</span> <span class="inlinecode"><span class="id" type="var">eqn</span>:...</span>:
        specify the name of an equation to be added to the context,
        recording the result of the case analysis

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">induction</span>...</span> <span class="inlinecode"><span class="id" type="keyword">as</span>...</span>:
        induction on values of inductively defined types 

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">inversion</span></span>:
        reason by injectivity and distinctness of constructors

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">assert</span></span> <span class="inlinecode">(<span class="id" type="var">e</span>)</span> <span class="inlinecode"><span class="id" type="keyword">as</span></span> <span class="inlinecode"><span class="id" type="var">H</span></span>:
        introduce a "local lemma" <span class="inlinecode"><span class="id" type="var">e</span></span> and call it <span class="inlinecode"><span class="id" type="var">H</span></span> 

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><span class="id" type="tactic">generalize</span></span> <span class="inlinecode"><span class="id" type="tactic">dependent</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span>:
        move the variable <span class="inlinecode"><span class="id" type="var">x</span></span> (and anything else that depends on it)
        from the context back to an explicit hypothesis in the goal
        formula 

</li>
</ul>

</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab183"></a><h1 class="section">Additional Exercises</h1>

<div class="paragraph"> </div>

<a name="lab184"></a><h4 class="section">Exercise: 3 stars (beq_nat_sym)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">beq_nat_sym</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>),<br/>
&nbsp;&nbsp;<span class="id" type="var">beq_nat</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> = <span class="id" type="var">beq_nat</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab185"></a><h4 class="section">Exercise: 3 stars, advanced, optional (beq_nat_sym_informal)</h4>
 Give an informal proof of this lemma that corresponds to your
    formal proof above:

<div class="paragraph"> </div>

   Theorem: For any <span class="inlinecode"><span class="id" type="var">nat</span></span>s <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span>, <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>.

<div class="paragraph"> </div>

   Proof:
   <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
<font size=-2>&#9744;</font>
 
<div class="paragraph"> </div>

<a name="lab186"></a><h4 class="section">Exercise: 3 stars, optional (beq_nat_trans)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">beq_nat_trans</span> : <span style="font-family: arial;">&forall;</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">beq_nat</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> = <span class="id" type="var">true</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;<span class="id" type="var">beq_nat</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span> = <span class="id" type="var">true</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;<span class="id" type="var">beq_nat</span> <span class="id" type="var">n</span> <span class="id" type="var">p</span> = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab187"></a><h4 class="section">Exercise: 3 stars, advanced (split_combine)</h4>
 We have just proven that for all lists of pairs, <span class="inlinecode"><span class="id" type="var">combine</span></span> is the
    inverse of <span class="inlinecode"><span class="id" type="tactic">split</span></span>.  How would you formalize the statement that
    <span class="inlinecode"><span class="id" type="tactic">split</span></span> is the inverse of <span class="inlinecode"><span class="id" type="var">combine</span></span>?

<div class="paragraph"> </div>

    Complete the definition of <span class="inlinecode"><span class="id" type="var">split_combine_statement</span></span> below with a
    property that states that <span class="inlinecode"><span class="id" type="tactic">split</span></span> is the inverse of
    <span class="inlinecode"><span class="id" type="var">combine</span></span>. Then, prove that the property holds. (Be sure to leave
    your induction hypothesis general by not doing <span class="inlinecode"><span class="id" type="tactic">intros</span></span> on more
    things than necessary.  Hint: what property do you need of <span class="inlinecode"><span class="id" type="var">l1</span></span>
    and <span class="inlinecode"><span class="id" type="var">l2</span></span> for <span class="inlinecode"><span class="id" type="tactic">split</span></span> <span class="inlinecode"><span class="id" type="var">combine</span></span> <span class="inlinecode"><span class="id" type="var">l1</span></span> <span class="inlinecode"><span class="id" type="var">l2</span></span> <span class="inlinecode">=</span> <span class="inlinecode">(<span class="id" type="var">l1</span>,<span class="id" type="var">l2</span>)</span> to be true?)  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">split_combine_statement</span> : <span class="id" type="keyword">Prop</span> :=<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">admit</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">split_combine</span> : <span class="id" type="var">split_combine_statement</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab188"></a><h4 class="section">Exercise: 3 stars (override_permute)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">override_permute</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) <span class="id" type="var">x1</span> <span class="id" type="var">x2</span> <span class="id" type="var">k1</span> <span class="id" type="var">k2</span> <span class="id" type="var">k3</span> (<span class="id" type="var">f</span> : <span class="id" type="var">nat</span><span style="font-family: arial;">&rarr;</span><span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;<span class="id" type="var">beq_nat</span> <span class="id" type="var">k2</span> <span class="id" type="var">k1</span> = <span class="id" type="var">false</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;(<span class="id" type="var">override</span> (<span class="id" type="var">override</span> <span class="id" type="var">f</span> <span class="id" type="var">k2</span> <span class="id" type="var">x2</span>) <span class="id" type="var">k1</span> <span class="id" type="var">x1</span>) <span class="id" type="var">k3</span> = (<span class="id" type="var">override</span> (<span class="id" type="var">override</span> <span class="id" type="var">f</span> <span class="id" type="var">k1</span> <span class="id" type="var">x1</span>) <span class="id" type="var">k2</span> <span class="id" type="var">x2</span>) <span class="id" type="var">k3</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab189"></a><h4 class="section">Exercise: 3 stars, advanced (filter_exercise)</h4>
 This one is a bit challenging.  Pay attention to the form of your IH. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">filter_exercise</span> : <span style="font-family: arial;">&forall;</span>(<span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">test</span> : <span class="id" type="var">X</span> <span style="font-family: arial;">&rarr;</span> <span class="id" type="var">bool</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">x</span> : <span class="id" type="var">X</span>) (<span class="id" type="var">l</span> <span class="id" type="var">lf</span> : <span class="id" type="var">list</span> <span class="id" type="var">X</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">filter</span> <span class="id" type="var">test</span> <span class="id" type="var">l</span> = <span class="id" type="var">x</span> :: <span class="id" type="var">lf</span> <span style="font-family: arial;">&rarr;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">test</span> <span class="id" type="var">x</span> = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab190"></a><h4 class="section">Exercise: 4 stars, advanced (forall_exists_challenge)</h4>
 Define two recursive <span class="inlinecode"><span class="id" type="var">Fixpoints</span></span>, <span class="inlinecode"><span class="id" type="var">forallb</span></span> and <span class="inlinecode"><span class="id" type="var">existsb</span></span>.  The
    first checks whether every element in a list satisfies a given
    predicate:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">forallb</span>&nbsp;<span class="id" type="var">oddb</span>&nbsp;[1;3;5;7;9]&nbsp;=&nbsp;<span class="id" type="var">true</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">forallb</span>&nbsp;<span class="id" type="var">negb</span>&nbsp;[<span class="id" type="var">false</span>;<span class="id" type="var">false</span>]&nbsp;=&nbsp;<span class="id" type="var">true</span><br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">forallb</span>&nbsp;<span class="id" type="var">evenb</span>&nbsp;[0;2;4;5]&nbsp;=&nbsp;<span class="id" type="var">false</span><br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">forallb</span>&nbsp;(<span class="id" type="var">beq_nat</span>&nbsp;5)&nbsp;[]&nbsp;=&nbsp;<span class="id" type="var">true</span>
<div class="paragraph"> </div>

</div>
    The second checks whether there exists an element in the list that
    satisfies a given predicate:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">existsb</span>&nbsp;(<span class="id" type="var">beq_nat</span>&nbsp;5)&nbsp;[0;2;3;6]&nbsp;=&nbsp;<span class="id" type="var">false</span><br/>
&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">existsb</span>&nbsp;(<span class="id" type="var">andb</span>&nbsp;<span class="id" type="var">true</span>)&nbsp;[<span class="id" type="var">true</span>;<span class="id" type="var">true</span>;<span class="id" type="var">false</span>]&nbsp;=&nbsp;<span class="id" type="var">true</span><br/>
&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">existsb</span>&nbsp;<span class="id" type="var">oddb</span>&nbsp;[1;0;0;0;0;3]&nbsp;=&nbsp;<span class="id" type="var">true</span><br/>
&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">existsb</span>&nbsp;<span class="id" type="var">evenb</span>&nbsp;[]&nbsp;=&nbsp;<span class="id" type="var">false</span>
<div class="paragraph"> </div>

</div>
    Next, define a <i>nonrecursive</i> version of <span class="inlinecode"><span class="id" type="var">existsb</span></span> &mdash; call it
    <span class="inlinecode"><span class="id" type="var">existsb'</span></span> &mdash; using <span class="inlinecode"><span class="id" type="var">forallb</span></span> and <span class="inlinecode"><span class="id" type="var">negb</span></span>.

<div class="paragraph"> </div>

    Prove that <span class="inlinecode"><span class="id" type="var">existsb'</span></span> and <span class="inlinecode"><span class="id" type="var">existsb</span></span> have the same behavior.

</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;$Date:&nbsp;2014-02-04&nbsp;07:15:43&nbsp;-0500&nbsp;(Tue,&nbsp;04&nbsp;Feb&nbsp;2014)&nbsp;$&nbsp;*)</span><br/>

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a><hr/>This page has been generated by <a href="http://www.lix.polytechnique.fr/coq/">coqdoc</a>
</div>

</div>

</body>
</html>